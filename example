Skip to content
 
Search or jump to…

Pull requests
Issues
Marketplace
Explore
 @pjmogan Sign out
2
0 0 Stanford-CS-190/repo1 Private
 Code  Issues 0  Pull requests 1  Projects 0  Wiki  Insights
repo1/src/raft_node.cc
b39bbaf  7 days ago
@zjiang23 zjiang23 Change srand() seeding from second-based to microsecond-based to avoi…
     
526 lines (468 sloc)  17.7 KB
#include "raft_node.h"
#include "logger.h"
#include <cstdlib>
#include <ctime>
#include <sys/time.h>

/**
 * Creates a RaftNode instance.
 *
 * \param filepath
 *      Path to folder where the persistent states will be read from / written to.
 * 
 *      Persistent state variables will be stored as the 'persistent_state_vars' file under this 
 *      path. Persistent logs will be stored as the 'persistent_logs' file under this path.
 *
 * \param self_node_id
 *      Node ID of this RaftNode instance.
 *
 * \param connection_config
 *      List of ConnectionConfig instances, one entry for each node in the cluster.
 *      The size of this vector will be used to determine the cluster size and the quorum size.
 * 
 *      Note: Membership changes are currently not supported.
 */
RaftNode::RaftNode(const std::string& filepath,
                   int self_node_id,
                   std::vector<ConnectionConfig> connection_config):
    self_node_id_(self_node_id),
    connection_config_(connection_config),
    serializer_(self_node_id_, connection_config_)
{
    // Initialize random seed for random-timeout
    struct timeval time_val;
    gettimeofday(&time_val, NULL);
    srand(time_val.tv_sec * 1000 + (int)(time_val.tv_usec / 1000));

    // Populate peer_node_ids_, check integrity
    bool self_in_list = false;
    for (auto config : connection_config_) {
        if (config.nodeid == self_node_id_) {
            self_in_list = true;
        } else {
            peer_node_ids_.insert(config.nodeid);
        }
    }

    // Assert: self_node_id_ must exist in the table
    assert(self_in_list);

    // Insert log entry 0 (dummy)
    log_.emplace_back(RaftProtoBuf::LogEntry());
    log_[0].set_term(0);
    log_[0].set_command("");

    // Initialize file paths
    filepath_vars_ = filepath + "persistent_state_vars";
    filepath_log_ = filepath + "persistent_logs";

    // Initialize ifstream_vars, recover persistent state variables from disk
    std::ifstream ifstream_vars;
    std::ifstream ifstream_log;
    ifstream_vars.open(filepath_vars_.c_str());
    if (ifstream_vars) {
        // If file opened successfully
        std::string persistent_state_str;
        if (ifstream_vars >> persistent_state_str) {
            // If string read successfully
            RaftProtoBuf::PersistentState persistent_state_proto;
            if (persistent_state_proto.ParseFromString(persistent_state_str)) {
                // If string parsed as RaftProtoBuf::PersistentState successfully
                // Load persistent state variables
                current_term_ = persistent_state_proto.current_term();
                voted_for_ = persistent_state_proto.voted_for();
            }
        }
    }
    ifstream_vars.close();

    // TODO (P2): Initialize ifstream_log_, recover log from disk

    // ofstream_vars_ is only opened at writing time, and will be closed immediately
    // i.e. nothing to do here

    // TODO (P2): Initialize ofstream_log_ (append mode)
}

/**
 * RaftNode destructor. Closes all open fstream instances.
 */
RaftNode::~RaftNode()
{
    if (!ofstream_vars_.is_open()){
        ofstream_vars_.close();
    }
    if (!ofstream_log_.is_open()){
        ofstream_log_.close();
    }
}

/**
 * Starts up the RaftNode, sending/receiving messages, updating local states accordingly.
 * Note: Loops infinitely.
 */
void
RaftNode::Run() {
    ResetRandomTimeout();

    int time_elapsed_;
    while (1) {
        // Time elapsed in milliseconds
        time_elapsed_ = (int)(difftime(time(0), timeout_start_) * 1000);

        switch (current_role_) {
            case Role::Leader: {
                if (time_elapsed_ >= (kHeartbeatTimeout)) {
                    // HeartbeatTimeout: send heartbeats
                    SendHeartbeat();
                }
                // TODO (P2): Receive command from client
                // TODO (P2): Check commit index, apply to statemachine, respond to client
                // TODO (P2): Feed followers who are behind
                
                // Receive and handle a new message
                ReceiveRaftMessage(kHeartbeatTimeout - time_elapsed_);
                break;
            }
            case Role::Candidate: {
                if (time_elapsed_ >= (kElectionTimeout + random_timeout_offset_)) {
                    // Timeout: start new election
                    BecomeNewCandidate();
                } else {
                    // Receive and handle a new message
                    ReceiveRaftMessage(kElectionTimeout + random_timeout_offset_ - time_elapsed_);
                }
                break;
            }
            case Role::Follower: {
                if (time_elapsed_ >= (kElectionTimeout + random_timeout_offset_)) {
                    // Timeout: start new election
                    BecomeNewCandidate();
                } else {
                    // Receive and handle a new message
                    ReceiveRaftMessage(kElectionTimeout + random_timeout_offset_ - time_elapsed_);
                }
                break;
            }
            default: {
                assert(false);
            }
        }
    }
}

// private methods below

/**
 * Attempts to receive and handle 1 new incoming message.
 * 
 * Returns after successfully receives and handles one message, or when the timeout is reached but
 * no complete message has been received.
 *
 * \param timeout
 *      Maximum amount of time (in milliseconds) to wait for an incoming message.
 */
void
RaftNode::ReceiveRaftMessage(int timeout) {
    RaftProtoBuf::RaftMessage raft_msg;
    int return_code = serializer_.ReceiveMessage(raft_msg, timeout);
    if (return_code == 0) {
        // Handle RaftMessage
        switch (raft_msg.type()) {
            case RaftProtoBuf::RaftMessage::APPEND_ENTRIES: {
                HandleAppendEntries(raft_msg.sender_id(),
                                    raft_msg.msg_append_entries());
                break;
            }
            case RaftProtoBuf::RaftMessage::APPEND_ENTRIES_RESPONSE: {
                HandleAppendEntriesResponse(raft_msg.sender_id(),
                                            raft_msg.msg_append_entries_response());
                break;
            }
            case RaftProtoBuf::RaftMessage::REQUEST_VOTE: {
                HandleRequestVote(raft_msg.sender_id(),
                                  raft_msg.msg_request_vote());
                break;
            }
            case RaftProtoBuf::RaftMessage::REQUEST_VOTE_RESPONSE: {
                HandleRequestVoteResponse(raft_msg.sender_id(),
                                          raft_msg.msg_request_vote_response());
                break;
            }
            default: {
                assert(false);
            }
        }
    }
}

/**
 * Handles one incoming RaftProtoBuf::AppendEntries message,
 * updating local states and sends RaftProtoBuf::AppendEntriesResponse accordingly.
 *
 * \param sender_id
 *      The message sender's node ID.
 *      Should be obtained from .sender_id() of the wrapping RaftProtoBuf::RaftMessage.
 *
 * \param msg
 *      Incoming RaftProtoBuf::AppendEntries message to be handled.
 */
void
RaftNode::HandleAppendEntries(int sender_id, const RaftProtoBuf::AppendEntries &msg) {
    // When incoming term is higher (or equal, for AppendEntries only) than local term
    if (msg.term() >= current_term_) {
        current_term_ = msg.term();
        voted_for_ = sender_id;  // acknowledge sender as leader
        current_role_ = Role::Follower;
        SavePersistentVars();
    }

    RaftProtoBuf::AppendEntriesResponse msg_response;
    msg_response.set_term(current_term_);

    // Raft cheatsheet, AppendEntries receiver #1
    // "Reply false if term < currentTerm"
    if (msg.term() < current_term_) {
        msg_response.set_success(false);
        serializer_.SendAppendEntriesResponse(std::vector<int>({sender_id}), msg_response);
        return;
    }

    // Raft cheatsheet, AppendEntries receiver #2
    // "Reply false if log doesn’t contain an entry at prevLogIndex whose term
    // matches prevLogTerm"
    if (log_.size() < msg.prev_log_index()
             || log_[msg.prev_log_index()].term() != msg.prev_log_term()) {
        msg_response.set_success(false);
        serializer_.SendAppendEntriesResponse(std::vector<int>({sender_id}), msg_response);
        return;
    }

    // Raft cheatsheet, AppendEntries receiver #3
    // "If an existing entry conflicts with a new one (same index but different terms),
    // delete the existing entry and all that follow it"
    // TODO (P2): Implement

    // Raft cheatsheet, AppendEntries receiver #4
    // "Append any new entries not already in the log"
    // TODO (P2): Implement

    // Raft cheatsheet, AppendEntries receiver #5
    // "If leaderCommit > commitIndex, set
    // commitIndex = min(leaderCommit, index of last new entry)"
    // TODO (P2): Implement
    // TODO (P2): Raft cheatsheet, AllServers #1
    //      If commitIndex > lastApplied: increment lastApplied,
    //      apply log[lastApplied] to state machine 

    // Reset election timeout
    ResetRandomTimeout();

    // Reply true
    msg_response.set_success(true);
    serializer_.SendAppendEntriesResponse(std::vector<int>({sender_id}), msg_response);
}

/**
 * Handles one incoming RaftProtoBuf::AppendEntriesResponse message, updating local states
 * accordingly.
 *
 * \param sender_id
 *      The message sender's node ID.
 *      Should be obtained from .sender_id() of the wrapping RaftProtoBuf::RaftMessage.
 *
 * \param msg
 *      Incoming RaftProtoBuf::AppendEntriesResponse message to be handled.
 */
void
RaftNode::HandleAppendEntriesResponse(int sender_id,
                                      const RaftProtoBuf::AppendEntriesResponse &msg) {
    // When incoming term is higher than local term
    if (msg.term() > current_term_) {
        current_term_ = msg.term();
        voted_for_ = -1;  // Reset voted_for_ state to not-yet-voted
        current_role_ = Role::Follower;
        SavePersistentVars();
    }

    // TODO (P2): Implement
}

/**
 * Handles one incoming RaftProtoBuf::RequestVote message,
 * updating local states and sends RaftProtoBuf::RequestVoteResponse accordingly.
 *
 * \param sender_id
 *      The message sender's node ID.
 *      Should be obtained from .sender_id() of the wrapping RaftProtoBuf::RaftMessage.
 *
 * \param msg
 *      Incoming RaftProtoBuf::RequestVote message to be handled.
 */
void
RaftNode::HandleRequestVote(int sender_id, const RaftProtoBuf::RequestVote &msg) {
    RaftProtoBuf::RequestVoteResponse msg_response;

    // When incoming term is higher than local term
    if (msg.term() > current_term_) {
        current_term_ = msg.term();
        voted_for_ = -1;  // Temporarily reset voted_for_ state to not-yet-voted
        current_role_ = Role::Follower;
        SavePersistentVars();
    }

    msg_response.set_term(current_term_);

    // Raft cheatsheet, RequestVote receiver #1
    // "Reply false if term < currentTerm"
    if (msg.term() < current_term_) {
        msg_response.set_vote_granted(false);
        serializer_.SendRequestVoteResponse(std::vector<int>({sender_id}), msg_response);
        return;
    }

    // Reject if sender_id is inconsistent with candidate_id field
    if (sender_id != msg.candidate_id()) {
        msg_response.set_vote_granted(false);
        serializer_.SendRequestVoteResponse(std::vector<int>({sender_id}), msg_response);
        return;
    }

    // Raft cheatsheet, RequestVote receiver #2
    // "If votedFor is null or candidateId, and candidate’s log is at least
    // as up-to-date as receiver’s log, grant vote"
    if (voted_for_ == -1 || voted_for_ == msg.candidate_id()) {
        // TODO (P2): Also check if candidate log is up to date
        msg_response.set_vote_granted(true);
        voted_for_ = msg.candidate_id();
        debuglog->Write(Logger::kApplication, "term = %d, voted for: %d", current_term_, voted_for_);
    } else {
        msg_response.set_vote_granted(false);
    }

    // Reset election timeout
    ResetRandomTimeout();

    serializer_.SendRequestVoteResponse(std::vector<int>({msg.candidate_id()}),
                                        msg_response);
}

/**
 * Handles one incoming RaftProtoBuf::RequestVoteResponse message, updating local states
 * accordingly.
 *
 * \param sender_id
 *      The message sender's node ID.
 *      Should be obtained from .sender_id() of the wrapping RaftProtoBuf::RaftMessage.
 *
 * \param msg
 *      Incoming RaftProtoBuf::RequestVoteResponse message to be handled.
 */
void
RaftNode::HandleRequestVoteResponse(int sender_id,
                                    const RaftProtoBuf::RequestVoteResponse &msg) {
    // When incoming term is higher than local term
    if (msg.term() > current_term_) {
        current_term_ = msg.term();
        voted_for_ = -1;  // Reset voted_for_ state to not-yet-voted
        current_role_ = Role::Follower;
        SavePersistentVars();
    }

    if (current_role_ == Role::Candidate && msg.term() == current_term_) {
        if (received_vote_[sender_id] == 0) {
            if (msg.vote_granted()) {
                received_vote_[sender_id] = 1;
                num_votes_received_++;
            } else {
                received_vote_[sender_id] = -1;
            }
            if (num_votes_received_ > ((peer_node_ids_.size() + 1) >> 1)) {
                // Received majority votes - become leader
                BecomeLeader();
            }
        }
        if (received_vote_[sender_id] == 1) {
            assert(msg.vote_granted());
        }
        if (received_vote_[sender_id] == -1) {
            assert(!msg.vote_granted());
        }
    }
}

/**
 * Increments the local term number, becomes candidate to a new round of election,
 * initializes candidate-use volatile states, and broadcasts RequestVote to all peers.
 *
 * Note: Can be called even when RaftNode is already at Role::Candidate,
 *       in which case the current_term_ will still get incremented
 *       and a new round of election will start from scratch.
 */
void
RaftNode::BecomeNewCandidate() {
    debuglog->Write(Logger::kApplication, "BecomeNewCandidate()");

    // Update states
    current_term_++;
    voted_for_ = self_node_id_;
    current_role_ = Role::Candidate;
    SavePersistentVars();

    debuglog->Write(Logger::kApplication, "Start election at term %d", current_term_);

    // Initialize volatile states for candidates
    received_vote_ = std::unordered_map<int, int>();
    for (auto id : peer_node_ids_) {
        received_vote_.emplace(id, 0);
    }
    received_vote_[self_node_id_] = 1;
    num_votes_received_ = 1;
    
    // Reset election timeout
    ResetRandomTimeout();

    // Send RequestVote messages to all other servers
    RaftProtoBuf::RequestVote msg;
    msg.set_term(current_term_);
    msg.set_candidate_id(self_node_id_);
    msg.set_last_log_index(log_.size() - 1);
    msg.set_last_log_term(log_.back().term());
    serializer_.SendRequestVote(std::vector<int>(peer_node_ids_.begin(),
                                                 peer_node_ids_.end()),
                                                 msg);
}

/**
 * Becomes the leader, initialize leader-use volatile states, and broadcast heartbeat messages to 
 * all peers.
 *
 * Must be called when the following statements all hold true:
 *      current_role_ == Role::Candidate
 *      voted_for_ == self_node_id_
 */
void
RaftNode::BecomeLeader() {
    debuglog->Write(Logger::kApplication, "BecomeLeader()");

    assert(current_role_ == Role::Candidate);
    assert(voted_for_ == self_node_id_);

    // Update states
    current_role_ = Role::Leader;

    // Reset election timeout
    ResetRandomTimeout();

    // Initialize volatile states for leaders
    next_index_ = std::unordered_map<int, int>();
    match_index_ = std::unordered_map<int, int>();
    for (auto id : peer_node_ids_) {
        received_vote_.emplace(id, 0);
    }

    // Broadcast initial heartbeat (AppendEntries)
    SendHeartbeat();
}

/**
 * Broadcasts heartbeat (RaftProtoBuf::AppendEntries with empty .entries()) messages to all peers.
 *
 * Must be called when the following statement holds true:
 *      current_role_ == Role::Leader
 */
void
RaftNode::SendHeartbeat() {
    debuglog->Write(Logger::kApplication, "SendHeartbeat()");

    assert(current_role_ == Role::Leader);

    // Reset timeout
    ResetRandomTimeout();

    // Send AppendEntries messages to all other servers
    RaftProtoBuf::AppendEntries msg;
    msg.set_term(current_term_);
    msg.set_leader_id(self_node_id_);
    msg.set_prev_log_index(0);
    msg.set_prev_log_term(0);
    msg.clear_entries();
    msg.set_leader_commit(commit_index_);
    serializer_.SendAppendEntries(std::vector<int>(peer_node_ids_.begin(),
                                                   peer_node_ids_.end()),
                                                   msg);
}

/**
 * Writes persistent state variables (current_term_ and voted_for_) to disk. Always overwrites
 * existing file on disk.
 */
void
RaftNode::SavePersistentVars() {
    debuglog->Write(Logger::kApplication, "SavePersistentVars()");

    ofstream_vars_.open(filepath_vars_.c_str());
    assert(ofstream_vars_);

    RaftProtoBuf::PersistentState persistent_state_proto;
    persistent_state_proto.set_current_term(current_term_);
    persistent_state_proto.set_voted_for(voted_for_);
    std::string persistent_state_str;
    persistent_state_proto.SerializeToString(&persistent_state_str);

    ofstream_vars_ << persistent_state_str;
    ofstream_vars_.close();
}

/**
 * Resets timeout_start_ to current timestamp, and randomly resets a value within 
 * [-kMaxRandomTimeout, kMaxRandomTimeout) for random_timeout_offset_.
 */
void
RaftNode::ResetRandomTimeout() {
    timeout_start_ = time(0);
    // -kMaxRandomTimeout <= random_timeout_offset_ < kMaxRandomTimeout
    random_timeout_offset_ = rand() % (kMaxRandomTimeout << 1) - kMaxRandomTimeout;
}
© 2019 GitHub, Inc.
Terms
Privacy
Security
Status
Help
Contact GitHub
Pricing
API
Training
Blog
About
Press h to open a hovercard with more details.
